import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  UseInterceptors,
  UploadedFile,
  StreamableFile,
  Res,
  InternalServerErrorException,
  UnsupportedMediaTypeException,
  Headers,
  ValidationPipe,
  BadRequestException,
  NotFoundException,
  ParseIntPipe,
  UseGuards,
  Request,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiConsumes,
  ApiParam,
  ApiBody,
  ApiResponse,
  ApiHeader,
  ApiBearerAuth,
} from '@nestjs/swagger';
import { Express } from 'express';
import { FileInterceptor } from '@nestjs/platform-express';
import { DocumentsService } from './documents.service';
import { createReadStream } from 'fs';
import type { Response } from 'express';
import { DocumentMetadata } from './dto/document-metadata.dto';
import { Document } from './entities/document.entity';
import { AuthGuard } from '../accounts/guards/auth.guard';

@ApiTags('documents')
@Controller('documents')
export class DocumentsController {
  constructor(private readonly documentService: DocumentsService) {}

  @UseGuards(AuthGuard)
  @Post()
  @ApiBearerAuth()
  @UseInterceptors(FileInterceptor('file'))
  @ApiOperation({
    summary:
      'Upload a document to server (WARNING: do not upload unencypted data!)',
    description:
      'WARNING: SERVER PERFORMS NO ENCRYPTION OR DECRYPTION. The server simply stores the file and associated metadata as it is, without any encryption, so you must encrypt the file and metadata on client side before uploading it to server. Server will not check if what it receives is encrypted or not, so if you upload unencrypted data, it will be stored as it is, unencrypted.',
  })
  @ApiConsumes('multipart/form-data')
  @ApiHeader({
    name: 'Content-Type',
    description:
      'NOTE: this header should not be shown in Swagger UI, as it already is handled by "Request body" section. TODO: remove it (see source code for details)',
    // HOW TO REMOVE THIS HEADER FROM "Parameters" SECTION IN SWAGGER UI":
    //
    // > Why removing this @ApiHeader decorator entry does not work:
    // Cuz then this entry will be generated by @nestjs/swagger because this route handler
    // uses @Headers decorator from @nestjs/common for validation,
    // and @nestjs/swagger integrates with that.
    //
    // > How to remove it:
    // There is no way to tell @nestjs/swagger to ignore @Headers decorator (AFAIK),
    // so we need to extract header validation logic to some middleware and use it instead,
    // After doing that, remove this @ApiHeader decorator entry.
    required: true,
    enum: ['multipart/form-data'],
  })
  @ApiBody({
    description: 'File and associated metadata',
    schema: {
      type: 'object',
      required: ['name', 'file', 'keys'],
      properties: {
        name: {
          type: 'string',
          description:
            'MUST BE ENCRYPTED WITH ASSOCIATED KEY (see `keys` field). File name (with extension), under which document will be stored on server',
          example: 'AAAAB3NzaC1yc2EAAAADAQABA',
        },
        file: {
          type: 'string',
          format: 'binary',
          description:
            'MUST BE ENCRYPTED WITH ASSOCIATED KEY (see `keys` field). The file to upload',
        },
        keys: {
          type: 'string',
          description:
            'MUST BE ENCRYPTED WITH USER PERSONAL KEY. Key that was used to encrypt `name` field and file that will be uploaded using this request. Must not be reused to encrypt anything else (yes, name is misleading because it is only one key, not many as the name "keys" suggests)',
          example: 'TODO: add example',
        },
      },
    },
  })
  @ApiResponse({
    status: 201,
    description: 'The document has been successfully uploaded.',
  })
  @ApiResponse({
    status: 400,
    description: 'Invalid request (e.g. missing or extra unknown field)',
  })
  @ApiResponse({
    status: 401,
    description: 'Unauthorized (missing or invalid JWT bearer token)',
  })
  @ApiResponse({
    status: 415,
    description: 'Invalid request media type (unsupported Content-Type)',
  })
  @ApiResponse({
    status: 500,
    description:
      'Failed to upload document because of some error on server (request was valid)',
  })
  async create(
    @Body(
      new ValidationPipe({
        whitelist: true,
        forbidNonWhitelisted: true,
        forbidUnknownValues: true,
        skipMissingProperties: false,
      }),
    )
    body: DocumentMetadata,
    @UploadedFile() file: Express.Multer.File,
    @Headers('Content-Type')
    contentType: string,
    @Request() req: any,
  ) {
    // TODO: maybe this and file checks could be extracted to some decorators, interceptors, pipes etc.
    if (!contentType.startsWith('multipart/form-data; boundary=')) {
      throw new UnsupportedMediaTypeException(
        `Unsupported media type (Content-Type): ${contentType}`,
      );
    }
    if (file === undefined) {
      throw new BadRequestException(
        'Missing `file` field that should upload file',
      );
    }
    if (file.size === 0) {
      throw new BadRequestException('Uploaded file cannot be empty');
    }
    try {
      return await this.documentService.create(
        body.name,
        file,
        body.keys,
        req.user.sub,
      );
    } catch (error) {
      // TODO: add { cause: error } for debugging
      // https://docs.nestjs.com/exception-filters
      throw new InternalServerErrorException(
        'This operation is temporarily unavailable due to some database service problem on our end, please try again later.',
      );
    }
  }

  @UseGuards(AuthGuard)
  @Get()
  @ApiBearerAuth()
  @ApiOperation({ summary: 'List all documents' })
  @ApiResponse({
    status: 200,
    description: 'The documents have been successfully listed',
    type: [Document],
  })
  @ApiResponse({
    status: 401,
    description: 'Unauthorized (missing or invalid JWT bearer token)',
  })
  @ApiResponse({
    status: 500,
    description:
      'Failed to list documents because of some error on server (request was valid)',
  })
  async findAll(@Request() req: any): Promise<Document[]> {
    try {
      return await this.documentService.findAll(req.user.sub);
    } catch (error) {
      // TODO: add { cause: error } for debugging
      // https://docs.nestjs.com/exception-filters
      throw new InternalServerErrorException(
        'This operation is temporarily unavailable due to some database service problem on our end, please try again later.',
      );
    }
  }

  @UseGuards(AuthGuard)
  @Get(':id')
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Download a document' })
  @ApiParam({
    name: 'id',
    description: 'The id of the document to download',
    type: 'integer',
    required: true,
  })
  @ApiResponse({
    status: 200,
    description: 'The document has been successfully downloaded',
    content: {
      'application/octet-stream': {
        schema: {
          description: 'The file content (exactly as it is stored on server)',
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  @ApiResponse({
    status: 401,
    description: 'Unauthorized (missing or invalid JWT bearer token)',
  })
  @ApiResponse({
    status: 404,
    description: 'Document with given id does not exist',
  })
  @ApiResponse({
    status: 400,
    description: 'Id is not valid (e.g. not a number)',
  })
  @ApiResponse({
    status: 500,
    description:
      'Failed to download document because of some error on server (request was valid)',
  })
  async findOne(
    @Param('id', ParseIntPipe) id: string,
    @Request() req: any,
    @Res({ passthrough: true }) res: Response,
  ): Promise<StreamableFile | void> {
    let document;
    try {
      document = await this.documentService.findOne(+id, req.user.sub);
    } catch (error) {
      // TODO: add { cause: error } for debugging
      // https://docs.nestjs.com/exception-filters
      throw new InternalServerErrorException(
        'This operation is temporarily unavailable due to some database service problem on our end, please try again later.',
      );
    }

    if (document) {
      res.set({
        'Content-Disposition': `attachment; filename="${document.name}"`,
      });
      const file = createReadStream(
        `${this.documentService.storagePath}/${document.userId}/${document.name}`,
      );
      return new StreamableFile(file);
    }
    throw new NotFoundException();
  }

  @UseGuards(AuthGuard)
  @Delete(':id')
  @ApiBearerAuth()
  @ApiOperation({
    summary: 'Delete a document (WARNING: this operation is irreversible!)',
  })
  @ApiParam({
    name: 'id',
    description: 'The id of the document to delete',
    type: 'integer',
    required: true,
  })
  @ApiResponse({
    status: 200,
    description:
      'The document has been successfully deleted or does not exist (this operation is idempotent)',
  })
  @ApiResponse({
    status: 401,
    description: 'Unauthorized (missing or invalid JWT bearer token)',
  })
  @ApiResponse({
    status: 500,
    description:
      'Failed to delete document because of some error on server (request was valid)',
  })
  async remove(@Param('id') id: string, @Request() req: any) {
    try {
      return await this.documentService.remove(+id, req.user.sub);
    } catch (error) {
      if (
        error.message ===
        `Cannot remove document from database, unknown document id #${id} or userId #${req.user.sub}`
      ) {
        return;
      }
      // TODO: add { cause: error } for debugging
      // https://docs.nestjs.com/exception-filters
      throw new InternalServerErrorException(
        'This operation is temporarily unavailable due to some database service problem on our end, please try again later.',
      );
    }
  }
}
